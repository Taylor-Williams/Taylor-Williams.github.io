---
layout: post
title:      "Ruby on Rails Javascript Singleton Woes"
date:       2019-04-17 08:36:37 +0000
permalink:  ruby_on_rails_javascript_singleton_woes
---

As I was modifying my Rails app to implement some Javascript I ran into tons of trouble finding an acceptable solution to providing a Javascript class to a single view (singleton). It was really, really frustrating and I still don't have an answer that feels *right* to me.

The problem starts out with the Rails asset pipeline. In theory it's great, it automatically precompiles all of your javascript for efficiency and then distributes it in a way that prevents a users' cache from missing updates to your JS. I'm all aboard. Except that you can only restrict certain javascript files to a resource namespace (or multiple if you like. that's just the smallest it goes...). Well that's not great for me, I wanted to display some comments dynamically, on-page, and there's only ONE view that would ever display those comments. That happens to be my Post resource, which is not only a full REST resource, it has many other nested resources under it's namespace. '/posts/:id' is the only time I wanted to use this Javascript, not any of the '/posts/:id/appointments/:id' and so on. So I did the usual google-foo and tried to find a neat solution to this and I found one that I liked: I created a js file in the usual app/assets/javascripts directory, added the name of that file to the precompile word array in the config/initializers/assets.rb file, and then added a "//= stub #{js_file_name}" line AFTER the require_tree line in application.js. your rails app is precompiling your js file, requiring it with all the other js files in app.js, and then stubbing it out from the JS file that's sent to the clients browser. The last step is to add a [ javascript_include_tag ](https://apidock.com/rails/ActionView/Helpers/AssetTagHelper/javascript_include_tag) in your Rails view file and voila, your JS is in your specified view only! And it worked the entire time that I did that for my first singleton class.

Short aside: If you are applying a JS file to modify any HTML element on the document you should add that line to the *very* end of your body element. Otherwise the HTML element may have not loaded and you will experience some problems. This is pretty much always. You should probably always just add the javascript include tag to the very end of your view file.

As I went to add my second singleton JS class things got kind of weird. I again added the filename to my precompiler array, I again stubbed it in app.js, and I again added a javascript_include_tag to my rails view file. This time the second singleton did not get included. I tried all kinds of stuff to troubleshoot; I switched the order of their file names in the precompiler. I switched the order of their file names in application.js. I tried all the possible combinations of said ordering. I switched the location within the view file where I called the javascript include tag (header, upper body, lower body). I changed the name of the js file itself (and corresponding references) in case of overriding variables through scope issues. I called the javascript include tag *twice*. Nothing worked.

Sometimes the file was called twice and caused problems, sometimes it was never called, but never was it called just once and working properly. I had tried everything I could think of and I wasn't recieving enough useful feedback to debug the issue so I decided to look for other singleton solutions. There's all sorts of tricks that people have used to get around it-- creating a unique namespace for the view you want, for example --but many of them didn't seem scalable enough to me to grab my attention. I'm not interested in messing up my routing or creating a labarynth in my app/javascripts directory every time I want a JS singleton. This should be something that I can set up initially in my environment and then be able to replicate easily throughout my application. This means that I was stuck with a poor solution given to me by Flatiron that I was trying to avoid the whole time. You can add a yield statement in your layout view file where you can add some singleton JS on demand. for me it went right above the ending body tag, "<%= yield :js %>". Then in your specific view file you access this yield using "<% content_for :js do %>".

There's a lot of reasons this feels bad. First off, you lose the precompilation. Big sucky. I'm not sure it makes that great of a difference, in fact maybe the first hack that I tried didn't even utilize precompilation, but I know that I'm missing out *for sure* and I dislike that. Second off, it makes my view file cumbersome and a mixture of languages. I've now got raw JS, HTML, and Ruby/Rails/Activerecord in a single file. I've also got some Handlebars in these files because I need to dynamically render some forms. This makes reading through the file and maintaining it a nightmare. And I'm the one who wrote it. Third, you break down a lot of separation of concerns that helps organize your rails application in other scenarios. This view is creating javascript models and doing the magic of accessing controllers for you. Taking the M and C out of MVC. Fourth, the code should not belong there considering that all my other javascript is in my app/assets/javascripts directory. There are many nice things about maintaining that structure like being able to write in coffeescript, browsing related javascript files on the server, and reducing confusion for anyone else who touches the application.

Suffice it to say this hack solution is really undesirable. It's mildly scalable and allows me to solve for my immediate needs but totally destroys modularity and maintainability principles. This solution was meant for adding simple event listeners to a couple elements, not creating full classes with instantiation of collections of objects and dynamic rendering. My alternative is bloating my users experience by forcing them to load javascript for *one* file across a whole spectrum of other pages. And these classes are looking for HTML elements that are specific to their pages, which means that errors will be firing on any other page they are privvy to. Realistically these singleton classes are comparatively very small and the errors *shouldn't* stop the pages from working correctly, but I'm certain that this alternative also doesn't scale very well and at some point would cause bugs in seemingly unrelated areas. And I'm fairly unwilling to sacrifice on efficiency if I can help it.

This all bothered me but I tabled the issue as I found something that was workable for the meantime. Another strange error started to occur, however, when I was playing around with my second singleton's page. If I left and came back to the page soon after none of my javascript worked. Weird. Console messages say that my Javascript class has already been instantiated. That's odd, I'm only calling for it once in my code... I again go through all the debugging I can think of, read into the documentation on Javascript topics, google-foo my error messages, test switching things around in the code. After a couple hours I find no solution and make no headway on places to look for a solution. I move on and as I'm watching a video about a different topic I hear the narrator explain that turbolinks (standard Rails gem) causes strange behaviors for javascript files that rely on jQuery's onload(). Bingo. I try to modify my code in a way that works with turbolinks but ultimately I only get it to reliably work by getting rid of the turbolinks gem. Hah! problem solved. I am victorious. turbolinks sucks, I'm the best.

So I have a working solution, but I hate it. I lose the efficiency of turbolinks and maintainability and modularity in the meantime. I don't know how long I want to spend on this issue because I know that I have other projects in mind and I know that I at least have a working iteration. I may try a combination of some of the things I've attempted and post my solution, but for the meantime beware the tales of Javascript singletons and Ruby on Rails.
