---
layout: post
title:      "Javascript Singleton Classes in Ruby on Rails"
date:       2019-04-17 04:36:38 -0400
permalink:  ruby_on_rails_javascript_singleton_woes
---

As I was modifying my Rails app to implement some Javascript I ran into tons of trouble finding an acceptable solution to providing a Javascript class to a single view (singleton). It was exceptionally frustrating and surprisingly it was one of those things that I couldn't find a proper guide to. I tried probably a dozen configurations before I found my current implementation and nowhere along the way did anyone say "this is the accepted best practice for JS singletons in Rails". Rails guides (which are usually extensive and very helpful), sprockets Github, turbolinks Github, dozens of StackOverflow posts, Rails source code comments... Nada. Each of them gave me a slightly better understanding of what's going on and common hacks that people use that I was eventually able to piece together. So, without further ado, let's get into solving Javascript singleton classes in Ruby on Rails.

Let's start off by understanding what your rails app is doing when your server responds to a GET request asking for HTML. When your server starts it will have already precompiled everything in the designated routes for the [Asset Pipeline](https://guides.rubyonrails.org/asset_pipeline.html). By default these locations are: app/assets, lib/assets, and vendor/assets. Precompilation is good, it makes things faster, we like this.

To accomplish this it goes through each file and makes sure it is the necessary file type before precompilation, this step is called prepocessing. If you ever wondered how your view files go from .html.erb to just .html, this is that step. It is also responsible for your CSS and JS files and can go through as many file types as you need as long as the code is compliant and your server knows how to process it. That is to say you could have a file ending in .js.coffee.erb and as long as you didn't have any errors it will be converted to a js file. the file extensions are read right to left so make sure your logic suits that pattern inside any files (erb -> html, then coffee -> js in the last example).

Next it packages all your .js files and .css files into one big bundle and labels it. This allows a browser to know when to update its cache of your css/js files; if the label changes it's time to re-download your files. You may have noticed an issue here. It is more efficient for your server to send out all your js files in a big bundle, but that makes singleton js files an issue; you don't want those files loading on every page, you want it on one(maybe a few) page(s). singleton files/classes are usually heavily interactant with the DOM and need to bind to specific elements that are *unique to a specific page* and will cause all sorts of problems if they are being used on every page.

After preprocessing, precompiling, bundling (and maybe minifying) your server sends the response back to the browser. You are probably familiar with the format, the files being used on the page are specified in the header and the content is in the body. By default Rails servers come with a very handy JS library that increases browser loading time on websites, Turbolinks. Turbolinks does a pretty smart thing where it reads the response of the server when any link is clicked and only refreshes the environment if the files in the header have changed. Otherwise it just replaces the HTML body of the document, saving tons of time for the user. Turbolinks is good, it makes things faster, we like this.

Except that it will give you debugging nightmares and will make you want to pull your hair out. I had no idea it was being used at all, and even after I knew I didn't recognize it was the source of much of my frustration. This is because it will cause you errors in your javascript/html/css and you won't know it happens *because* of Turbolinks. This causes a lot of people to give up on Turbolinks and remove it when implementing much javascript. Hack solutions are significantly easier without it, but knowing that you made the rest of your website experience inefficient because of a couple javascript files feels sucky. very sucky indeed.

I'd love to go through all the solutions I tried and why they didn't work, but it would be long and that's probably not why you are here. Instead I'm going to list the properties that our solution will need to have and how we should organize everything as a result.

Here's what we want:
* our Javascript loading on *only* the desired page(s). **once**.
* precompilation of our js singletons
* caching to not cause errors on future pages for users
* maintenance of separation of concerns. HTML in view files, JS in js files.

Here's what that looks like:
* Continue adding your js files to your main pathway -- /app/assets/javascripts for most people. In application.js of the aforementioned path add "//= stub #{your_file_name}.js" *after* the "//= require_tree ." line. For example if your singleton file was named comment.js, you would write "//= stub comment.js". This achieves removing your file from the main bundle.
* Add this same file to the precompile list so your application still precompiles it. Stubbing it in the previous step tells your app to not precompile by default. In Rails 5 the file located at /config/initializers/assets.rb will have a line with the text: "Rails.application.config.assets.precompile" in it. make sure that line is uncommented and add your filename to the "+= %w()" parenthesis like so: "Rails.application.config.assets.precompile += %w( comment.js )".
* In your layouts that will use singleton files add a yield statement in the header tag for adding js files. The default layout is in /app/views/layouts/application.html.erb, but every layout that displays a page containing a js singleton must contain this yield line. This is not your default yield block, so label it with the symbol that makes most sense to you. for me this looks like: "<%= yield :js %>". **if your file relies on any js file from your main bundle add this line after the javascript_include_tag  for 'application'**. This includes jquery or any other framework you are using. Best practice should be to have this yield statement on the line after including your application.js file.
* Within the view file for the page you want to utilize your singleton include a javascript_include_tag inside a content_for tag *that is labeled with the same symbol you used in your yield statement in the last step*. That was a lot of words, so let me show you what that looks like using the same comment.js example from before: 
"<% content_for :js do %>
  <%= javascript_include_tag 'comment', 'data-turbolinks-track': 'reload' %>
<% end %>"
**you will also want to include this 'data-turbolinks-track': 'reload' line**. This ensures that users will reload the page if you update the js file while they are on it. You should be able to add this line anywhere in your view file but this is something I haven't bugtested.
* Lastly in your singleton js file itself make sure that you are not using Jquery's onLoad(). Turbolinks can mess with the timing of how things load in the browser and if you are using $.on("load") the js file could potentially try binding to elements that have yet to load on your page yet. Instead use  "$(document).on("turbolinks:load")" to ensure all the elements load before you try accessing them.

This should ensure we have all the properties we were looking for. Lots of older "hack" solutions involved including the javascript file at the very end of the body of the document. With turbolinks you will encounter a bunch of issues trying this method. one reason might be the onload issue mentioned above, but the larger one will be that turbolinks won't know that you added a singleton to the documents' environment. It validates the environment doesn't need to be refreshed by reading the head of the document, not the body. It will then carry it on to other pages trying to bind to elements that do not exist anymore and if you come back to the original page your singleton will be called again. This means you will face errors of trying to re-initialize a class that was already defined. This kills the javascript.

Go forth and kick Railsy/javascripty butt.
